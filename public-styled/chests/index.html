<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Lucky Chests — Troop 248</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" type="image/png" href="/bsafavicon.ico">

  <style>
    :root {
      --red: #b22222;
      --blue: #1f4e79;
      --tan: #f4eee3;
      --white: #ffffff;
      --text-main: #1f2933;
      --text-muted: #6b7280;
      --radius-lg: 16px;
      --radius-pill: 999px;
      --shadow-soft: 0 10px 25px rgba(0, 0, 0, 0.06);
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #d2cab6;
      color: var(--text-main);
      min-height: 100vh;
    }

    header {
      background: linear-gradient(120deg, #b22222, #ffffff, #1f4e79);
      color: var(--white);
      padding: 14px 24px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      position: sticky;
      top: 0;
      z-index: 10;
    }

    header h2 {
      margin: 0;
      font-size: 19px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    header h2::before { content: "★"; font-size: 18px; }

    .troop-home-link {
      text-decoration: none;
      color: inherit;
      display: inline-flex;
      align-items: center;
    }

    .troop-home-link:hover h2 {
      opacity: 0.9;
      text-decoration: underline;
    }

    nav {
      display: flex;
      gap: 12px;
      font-size: 13px;
      text-transform: uppercase;
    }

    nav a {
      color: #1f4e79;
      font-weight: bold;
      text-decoration: none;
      padding: 6px 10px;
      border-radius: var(--radius-pill);
      border: 1px solid rgba(255, 255, 255, 0.25);
      backdrop-filter: blur(4px);
      opacity: 0.9;
    }

    nav a:hover {
      opacity: 1;
      background: rgba(255, 255, 255, 0.12);
    }

    #auth-bar {
      display: flex;
      gap: 10px;
      align-items: center;
      font-size: 13px;
    }

    .auth-btn {
      padding: 5px 12px;
      font-size: 13px;
      border-radius: var(--radius-pill);
      border: 1px solid rgba(255, 255, 255, 0.7);
      background: rgba(255, 255, 255, 0.1);
      color: var(--white);
      cursor: pointer;
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
    }
    .auth-btn:hover { background: rgba(255, 255, 255, 0.2); }

    main {
      padding: 24px 16px 40px;
      max-width: 960px;
      margin: 0 auto;
    }

    .welcome-card {
      background: rgba(255, 255, 255, 0.95);
      border-radius: var(--radius-lg);
      padding: 18px 18px 8px;
      margin-bottom: 20px;
      box-shadow: var(--shadow-soft);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
      border: 1px solid rgba(148, 163, 184, 0.4);
    }

    .welcome-card h3 { margin: 0 0 4px; font-size: 18px; }
    .welcome-card p { margin: 0; font-size: 14px; color: var(--text-muted); }

    .badge {
      font-size: 11px;
      padding: 4px 8px;
      border-radius: var(--radius-pill);
      background: rgba(148, 163, 184, 0.2);
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.07em;
      display: inline-flex;
      gap: 6px;
      align-items: center;
      justify-content: center;
    }

    .badge.admin {
      background: rgba(240, 180, 41, 0.16);
      color: #92400e;
      border: 1px solid rgba(245, 158, 11, 0.6);
    }

    section {
      background: rgba(255, 255, 255, 0.95);
      border-radius: var(--radius-lg);
      padding: 18px 18px 14px;
      margin-bottom: 18px;
      box-shadow: var(--shadow-soft);
      border: 1px solid rgba(148, 163, 184, 0.4);
    }

    section h2 {
      margin-top: 0;
      font-size: 18px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    section h2::before {
      content: "▸";
      font-size: 14px;
      color: var(--blue);
    }

    .small-help {
      font-size: 12px;
      color: var(--text-muted);
      margin-top: 6px;
      line-height: 1.35;
    }

    .row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }

    .pillbox {
      display: inline-flex;
      gap: 10px;
      align-items: center;
      padding: 8px 10px;
      border-radius: var(--radius-pill);
      border: 1px solid rgba(148, 163, 184, 0.55);
      background: rgba(148, 163, 184, 0.10);
      font-size: 12px;
      color: var(--text-muted);
    }

    .pillbox strong {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      color: var(--text-main);
      font-size: 12px;
    }

    .primary-btn {
      padding: 7px 14px;
      border-radius: var(--radius-pill);
      border: none;
      background: var(--blue);
      color: #ffffff;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
    }
    .primary-btn:hover { opacity: 0.96; }
    .primary-btn:disabled { opacity: 0.55; cursor: not-allowed; }

    .error {
      margin-top: 10px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(185, 28, 28, 0.35);
      background: rgba(185, 28, 28, 0.08);
      color: #991b1b;
      display: none;
      font-size: 13px;
    }
    .error.show { display: block; }

    /* Badges */
    .badges {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 12px;
      margin-top: 8px;
    }
    @media (max-width: 640px) { .badges { grid-template-columns: 1fr; } }

    .badge-card {
  border: 1px solid rgba(31, 78, 121, 0.18);
  background: rgba(31, 78, 121, 0.06);   /* soft blue tint */
  border-radius: 14px;
  padding: 12px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.05);
}
    .badge-top {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 10px;
    }
    .badge-name {
      font-weight: 800;
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--blue);
      margin: 0;
    }
    .badge-meta {
      margin-top: 3px;
      font-size: 12px;
      color: var(--text-muted);
      line-height: 1.35;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    .badge-count {
      font-size: 12px;
      padding: 4px 8px;
      border-radius: var(--radius-pill);
      background: rgba(31,78,121,0.10);
      border: 1px solid rgba(31,78,121,0.18);
      color: #1f4e79;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      white-space: nowrap;
    }
    .upgrade-btn {
      margin-top: 10px;
      width: 100%;
      padding: 8px 12px;
      border-radius: var(--radius-pill);
      border: none;
      background: rgba(34, 197, 94, 0.16);
      border: 1px solid rgba(34, 197, 94, 0.35);
      color: #166534;
      font-weight: 700;
      cursor: pointer;
      display: none;
    }
    .upgrade-btn:hover { opacity: 0.96; }

    /* Fullscreen chest overlay (kept simple but “exciting”) */
    .overlay { position: fixed; inset: 0; display: none; z-index: 9999; user-select: none; }
    .overlay.show { display: block; }

    .ov-top {
      position: absolute;
      left: 18px;
      right: 18px;
      top: 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      pointer-events: none;
      color: white;
    }

    .ov-title .name { font-weight: 900; letter-spacing: 0.05em; text-transform: uppercase; font-size: 13px; }
    .ov-title .small { margin-top: 3px; font-size: 12px; opacity: 0.92; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }

    .ov-dots { display: flex; gap: 6px; }
    .dot { width: 10px; height: 10px; border-radius: 999px; border: 1px solid rgba(255,255,255,0.45); background: rgba(255,255,255,0.15); }
    .dot.done { background: rgba(255,255,255,0.85); }

    .ov-center {
      position: absolute; inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 86px 16px 110px;
      text-align: center;
      color: white;
    }

    .chest-wrap { width: min(560px, 92vw); display: flex; flex-direction: column; align-items: center; gap: 14px; }
    .chest {
      width: min(360px, 80vw);
      height: min(230px, 50vw);
      border-radius: 22px;
      border: 1px solid rgba(255,255,255,0.25);
      box-shadow: 0 18px 60px rgba(0,0,0,0.35);
      position: relative;
      overflow: hidden;
    }
    .chest::before{
      content:""; position:absolute; inset:-60px;
      background:
        radial-gradient(circle at 30% 20%, rgba(255,255,255,0.30), transparent 55%),
        radial-gradient(circle at 70% 75%, rgba(255,255,255,0.16), transparent 60%);
      opacity: 0.9;
    }
    .shake { animation: shake 520ms ease-in-out; }
    @keyframes shake{
      0%{ transform: translateY(0) rotate(0deg); }
      15%{ transform: translateY(-2px) rotate(-1deg); }
      35%{ transform: translateY(1px) rotate(1deg); }
      55%{ transform: translateY(-1px) rotate(-1deg); }
      75%{ transform: translateY(1px) rotate(0.7deg); }
      100%{ transform: translateY(0) rotate(0deg); }
    }

    .level { margin: 0; font-size: 44px; font-weight: 950; letter-spacing: 0.04em; text-shadow: 0 22px 70px rgba(0,0,0,0.45); }
    .level-sub { margin: 0; font-size: 12px; opacity: 0.92; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace; }

    .ladder { display: flex; gap: 8px; flex-wrap: wrap; justify-content: center; }
    .rung { width: 40px; height: 10px; border-radius: 999px; border: 1px solid rgba(255,255,255,0.35); background: rgba(255,255,255,0.14); opacity: 0.55; }
    .rung.on { opacity: 1; background: rgba(255,255,255,0.88); }

    .toast{
      position:absolute; left:50%; top: 58%;
      transform: translate(-50%,-50%);
      padding: 10px 14px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,0.22);
      background: rgba(0,0,0,0.24);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      font-size: 14px; font-weight: 900; letter-spacing: 0.02em;
      opacity: 0; pointer-events:none;
      box-shadow: 0 18px 60px rgba(0,0,0,0.35);
      backdrop-filter: blur(8px);
      color: white;
    }
    .toast.show{ animation: toastpop 780ms ease-out; }
    @keyframes toastpop{
      0%{ opacity: 0; transform: translate(-50%,-50%) scale(0.95); }
      20%{ opacity: 1; transform: translate(-50%,-50%) scale(1.02); }
      55%{ opacity: 1; transform: translate(-50%,-50%) scale(1.0); }
      100%{ opacity: 0; transform: translate(-50%,-50%) scale(1.0); }
    }

    .result{
      display:none;
      margin-top: 6px;
      padding: 12px 14px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.25);
      background: rgba(0,0,0,0.22);
      width: min(560px, 92vw);
      backdrop-filter: blur(10px);
      text-align: left;
      color: white;
    }
    .result.show { display: block; }
    .result h3 { margin: 0 0 6px 0; font-size: 14px; font-weight: 950; }
    .result p { margin: 0; font-size: 13px; opacity: 0.92; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace; }
    .result .ok {
      margin-top: 10px;
      width: 100%;
      padding: 9px 12px;
      border-radius: var(--radius-pill);
      border: none;
      background: rgba(255,255,255,0.18);
      color: white;
      font-weight: 800;
      cursor: pointer;
    }
    .result .ok:hover { opacity: 0.96; }

    /* Level themes */
    .t1{ background: radial-gradient(900px 650px at 25% 10%, rgba(80,120,255,0.22), transparent 60%), linear-gradient(180deg, #07102a, #060a18); }
    .t2{ background: radial-gradient(900px 650px at 25% 10%, rgba(255,200,120,0.28), transparent 60%), linear-gradient(180deg, #2a1306, #120806); }
    .t3{ background: radial-gradient(900px 650px at 25% 10%, rgba(200,120,255,0.26), transparent 60%), linear-gradient(180deg, #140a28, #070610); }
    .t4{ background: radial-gradient(900px 650px at 25% 10%, rgba(120,220,255,0.28), transparent 60%), linear-gradient(180deg, #061b2c, #040b14); }
    .t5{ background: radial-gradient(900px 650px at 25% 10%, rgba(240,240,255,0.22), transparent 60%), linear-gradient(180deg, #0f1116, #07080a); }
    .t6{ background: radial-gradient(900px 650px at 25% 10%, rgba(255,220,120,0.30), transparent 60%), linear-gradient(180deg, #1c1206, #090603); }

    .skin1{ background: linear-gradient(180deg, rgba(70,120,220,0.28), rgba(10,30,70,0.24)); }
    .skin2{ background: linear-gradient(180deg, rgba(255,170,70,0.30), rgba(90,30,10,0.22)); }
    .skin3{ background: linear-gradient(180deg, rgba(200,110,255,0.28), rgba(50,10,80,0.22)); }
    .skin4{ background: linear-gradient(180deg, rgba(140,230,255,0.24), rgba(10,40,80,0.20)); }
    .skin5{ background: linear-gradient(180deg, rgba(240,240,255,0.26), rgba(40,45,60,0.18)); }
    .skin6{ background: linear-gradient(180deg, rgba(255,220,120,0.28), rgba(90,50,10,0.20)); }
  </style>

  <link rel="stylesheet" href="/modern-2026.css" />
</head>

<body>
  <header>
    <div>
      <a href="/home" class="troop-home-link">
        <h2>Troop 248</h2>
      </a>
    </div>

    <nav>
      <a href="/home">Home</a>
      <a href="/calendar">Calendar</a>
      <a href="/documents">Documents</a>
      <a href="/scoutmaster">SM Blog</a>
      <a href="/spl">SPL Blog</a>
      <a href="/useful-links">Useful Links</a>
      <a href="/events">Events</a>
      <a href="/mail">Mail</a>
      <a href="/chests">Chests</a>
    </nav>

    <div id="auth-bar">
      <div id="auth-info">Not signed in</div>
      <a id="login-link" class="auth-btn" href="/login/">Log In</a>
      <button id="logout-btn" class="auth-btn" style="display:none;">Log Out</button>
    </div>
  </header>

  <main>
    <div class="welcome-card">
      <div>
        <h3>Lucky Chests</h3>
        <p>Open chests to collect badge cards (names later). This page can be viewed without signing in.</p>
      </div>
      <div id="role-badge-container">
        <span class="badge">Guest</span>
      </div>
    </div>

    <section>
      <h2>Your Chests</h2>
      <div class="row">
        <div class="pillbox">
          <span>Lucky Chests:</span>
          <strong id="lucky-count">0</strong>
        </div>

        <button id="open-chest-btn" class="primary-btn" disabled>Open Lucky Chest</button>
      </div>

      <div class="small-help" id="open-help">
        If you sign in, you can open chests and collect badge cards.
      </div>

      <div id="errBox" class="error"></div>

      <div class="small-help" style="margin-top:10px;">
        Admins can “give” chests by setting <strong>users/{uid}.chests.lucky</strong> in Firestore.
      </div>
    </section>

    <section>
      <h2>Badges</h2>
      <div class="small-help">
        Cards only go up. Upgrading is manual and uses your card requirements. (You can remove upgrades later.)
      </div>
      <div id="badgesGrid" class="badges"></div>
      <div class="small-help" id="badges-help" style="margin-top:10px;">
        Sign in to see your badge progress.
      </div>
    </section>
  </main>

  <!-- Fullscreen Chest Overlay -->
  <div class="overlay t1" id="overlay">
    <div class="ov-top">
      <div class="ov-title">
        <div class="name">Lucky Chest</div>
        <div class="small" id="spinLabel">Spin 1 of 5 • Spins left: 5</div>
      </div>
      <div class="ov-dots" id="dots"></div>
    </div>

    <div class="ov-center">
      <div class="chest-wrap">
        <div class="chest skin1" id="chest"></div>
        <h2 class="level" id="levelText">LEVEL 1</h2>
        <p class="level-sub" id="levelSub">Tap anywhere to spin</p>
        <div class="ladder" id="ladder"></div>
        <div class="toast" id="toast"></div>

        <div class="result" id="result">
          <h3 id="resultTitle">Complete</h3>
          <p id="resultBody">—</p>
          <button class="ok" id="resultOk">Collect & Close</button>
        </div>
      </div>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js";
    import { getAuth, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-auth.js";
    import { getFirestore, doc, getDoc, setDoc, onSnapshot, runTransaction, serverTimestamp, updateDoc } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js";

    const firebaseConfig = {
      apiKey: "AIzaSyD5qUHa2JuQ3iI7U3DrX7JDyhx76PGzhxM",
      authDomain: "troop-248.firebaseapp.com",
      projectId: "troop-248",
      storageBucket: "troop-248.firebasestorage.app",
      messagingSenderId: "925363875752",
      appId: "1:925363875752:web:0b001c1a7a09fb8232f79d",
      measurementId: "G-NY75GX5TBH"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);

    // ====== UI ======
    const authInfoEl = document.getElementById("auth-info");
    const loginLink = document.getElementById("login-link");
    const logoutBtn = document.getElementById("logout-btn");
    const roleBadgeContainer = document.getElementById("role-badge-container");

    const luckyCountEl = document.getElementById("lucky-count");
    const openChestBtn = document.getElementById("open-chest-btn");
    const openHelp = document.getElementById("open-help");
    const badgesGrid = document.getElementById("badgesGrid");
    const badgesHelp = document.getElementById("badges-help");
    const errBox = document.getElementById("errBox");

    const overlay = document.getElementById("overlay");
    const spinLabel = document.getElementById("spinLabel");
    const chestEl = document.getElementById("chest");
    const levelText = document.getElementById("levelText");
    const levelSub = document.getElementById("levelSub");
    const ladder = document.getElementById("ladder");
    const toast = document.getElementById("toast");
    const dots = document.getElementById("dots");
    const result = document.getElementById("result");
    const resultTitle = document.getElementById("resultTitle");
    const resultBody = document.getElementById("resultBody");
    const resultOk = document.getElementById("resultOk");

    function showError(msg) {
      errBox.textContent = msg;
      errBox.classList.add("show");
      setTimeout(() => errBox.classList.remove("show"), 5200);
    }

    // ====== Game Settings ======
    const FINAL_LEVEL_WEIGHTS = [
      { level: 1, p: 0.10 },
      { level: 2, p: 0.375 },
      { level: 3, p: 0.225 },
      { level: 4, p: 0.175 },
      { level: 5, p: 0.075 },
      { level: 6, p: 0.05 }
    ];

    // Temporary badge ids (rename later without changing ids)
    const BADGES = {
      Common:     ["a","b","c","d","e"],
      Uncommon:   ["f","g","h","i","j"],
      Rare:       ["k","l","m","n","o"],
      Epic:       ["p","q","r","s","t"],
      Legendary:  ["u","v","w","x","y"],
    };
    const RARITY_ORDER = ["Common","Uncommon","Rare","Epic","Legendary"];

    const CARD_REWARD_TABLE = {
      1: { Common: 20 },
      2: { Common: 50, Uncommon: 5 },
      3: { Common: 150, Uncommon: 15, Rare: 5 },
      4: { Common: 225, Uncommon: 35, Rare: 15, Epic: 8 },
      5: { Common: 350, Uncommon: 55, Rare: 35, Epic: 20, Legendary: 3 },
      6: { Common: 500, Uncommon: 100, Rare: 65, Epic: 40, Legendary: 10 },
    };

    // Upgrades (cards only) – matches what you described
    const COMMON_STEP_COST = { 1:25, 2:50, 3:100, 4:250, 5:550, 6:800, 7:1400, 8:2000 };
    const RARITY_CARD_MULT = { Common:1.0, Uncommon:0.70, Rare:0.40, Epic:0.20, Legendary:0.05 };
    function nextCardCost(rarity, currentLevel) {
      const base = COMMON_STEP_COST[currentLevel];
      if (!base) return null;
      return Math.floor(base * (RARITY_CARD_MULT[rarity] ?? 1));
    }

    // ====== State ======
    let currentUser = null;
    let currentIsAdmin = false;
    let unsubUserDoc = null;

    let luckyChests = 0;
    let badgeCards = {};
    let badgeLevels = {};

    // chest session
    let opening = false;
    let spinIndex = 0;
    let currentLevel = 1;
    let outcomes = [];
    let finalLevel = 1;
    let decidedDrop = null;

    // ====== Firestore helpers ======
    const userDocRef = (uid) => doc(db, "users", uid);

    function ensureAllBadgesInitialized(levelsObj) {
      const out = { ...(levelsObj || {}) };
      for (const rarity of RARITY_ORDER) {
        for (const id of BADGES[rarity]) {
          if (typeof out[id] !== "number" || out[id] < 1) out[id] = 1;
        }
      }
      return out;
    }

    async function ensureUserDoc(uid) {
      const ref = userDocRef(uid);
      const snap = await getDoc(ref);

      if (!snap.exists()) {
        await setDoc(ref, {
          chests: { lucky: 0 },
          badgeCards: {},
          badgeLevels: ensureAllBadgesInitialized({}),
          createdAt: serverTimestamp()
        });
        return;
      }

      const data = snap.data() || {};
      const updates = {};

      if (typeof data.chests !== "object" || data.chests === null) updates.chests = { lucky: 0 };
      else if (typeof data.chests.lucky !== "number") updates.chests = { ...data.chests, lucky: 0 };

      if (typeof data.badgeCards !== "object" || data.badgeCards === null) updates.badgeCards = {};
      if (typeof data.badgeLevels !== "object" || data.badgeLevels === null) updates.badgeLevels = ensureAllBadgesInitialized({});
      else {
        const merged = ensureAllBadgesInitialized(data.badgeLevels);
        const changed = Object.keys(merged).some(k => merged[k] !== data.badgeLevels[k]);
        if (changed) updates.badgeLevels = merged;
      }

      if (Object.keys(updates).length) await updateDoc(ref, updates);
    }

    function subscribeToUserDoc(uid) {
      if (unsubUserDoc) unsubUserDoc();
      unsubUserDoc = onSnapshot(userDocRef(uid), (snap) => {
        const data = snap.data() || {};
        luckyChests = (data.chests && typeof data.chests.lucky === "number") ? data.chests.lucky : 0;
        badgeCards = (typeof data.badgeCards === "object" && data.badgeCards) ? data.badgeCards : {};
        badgeLevels = ensureAllBadgesInitialized(
          (typeof data.badgeLevels === "object" && data.badgeLevels) ? data.badgeLevels : {}
        );

        luckyCountEl.textContent = String(luckyChests);
        openChestBtn.disabled = !currentUser || opening || luckyChests < 1;

        openHelp.textContent =
          luckyChests < 1
            ? "You have no Lucky Chests right now."
            : "Click Open to consume 1 chest and start the 5 spins.";

        renderBadges();
      });
    }

    // ====== Auth / Role (do not force-login) ======
    function setGuestUI() {
      authInfoEl.textContent = "Not signed in";
      roleBadgeContainer.innerHTML = `<span class="badge">Guest</span>`;
      loginLink.style.display = "";
      logoutBtn.style.display = "none";

      luckyChests = 0;
      badgeCards = {};
      badgeLevels = {};
      luckyCountEl.textContent = "0";
      openChestBtn.disabled = true;
      openHelp.textContent = "If you sign in, you can open chests and collect badge cards.";
      badgesHelp.textContent = "Sign in to see your badge progress.";
      badgesHelp.style.display = "block";
      badgesGrid.innerHTML = "";
      if (unsubUserDoc) unsubUserDoc();
    }

    async function handleSignedInUser(user) {
      // role gate like your other pages, but only AFTER sign-in
      const infoRef = doc(db, "accountInfo", user.uid);
      const infoSnap = await getDoc(infoRef);

      if (!infoSnap.exists()) {
        window.location.href = "/under-review/";
        return;
      }

      const data = infoSnap.data();
      const role = data.authRole;

      if (role !== "admin" && role !== "viewer") {
        window.location.href = "/under-review/";
        return;
      }

      currentIsAdmin = (role === "admin");

      authInfoEl.textContent = `Signed in as ${user.email}`;
      roleBadgeContainer.innerHTML = `
        <span class="badge ${currentIsAdmin ? "admin" : ""}">
          ${currentIsAdmin ? "Admin" : "Viewer"}
        </span>
      `;
      loginLink.style.display = "none";
      logoutBtn.style.display = "";

      badgesHelp.style.display = "none";

      await ensureUserDoc(user.uid);
      subscribeToUserDoc(user.uid);
    }

    onAuthStateChanged(auth, async (user) => {
      currentUser = user || null;

      if (!currentUser) {
        setGuestUI();
        return;
      }

      try {
        await handleSignedInUser(currentUser);
      } catch (e) {
        showError(e?.message || "Could not load your account.");
      }
    });

    logoutBtn.addEventListener("click", async () => {
      await signOut(auth);
      // keep page viewable after sign out
      setGuestUI();
    });

    // ====== Badges UI ======
    function allBadgeIdsInOrder() {
      const list = [];
      for (const rarity of RARITY_ORDER) {
        for (const id of BADGES[rarity]) list.push({ id, rarity });
      }
      return list;
    }
    function getLevelForBadge(id) {
      const v = badgeLevels?.[id];
      return (typeof v === "number" && v >= 1) ? v : 1;
    }
    function getCardsForBadge(id) {
      const v = badgeCards?.[id];
      return (typeof v === "number" && v >= 0) ? v : 0;
    }

    async function upgradeBadge(badgeId, rarity) {
      if (!currentUser) {
        showError("Please sign in first (use the Login button).");
        return;
      }

      try {
        await runTransaction(db, async (tx) => {
          const ref = userDocRef(currentUser.uid);
          const snap = await tx.get(ref);
          const data = snap.data() || {};

          const bc = (typeof data.badgeCards === "object" && data.badgeCards) ? { ...data.badgeCards } : {};
          const bl = ensureAllBadgesInitialized(
            (typeof data.badgeLevels === "object" && data.badgeLevels) ? { ...data.badgeLevels } : {}
          );

          const lvl = (typeof bl[badgeId] === "number" && bl[badgeId] >= 1) ? bl[badgeId] : 1;
          const cost = nextCardCost(rarity, lvl);
          if (cost === null) throw new Error("Max upgrades reached.");

          const cards = (typeof bc[badgeId] === "number" && bc[badgeId] >= 0) ? bc[badgeId] : 0;
          if (cards < cost) throw new Error("Not enough cards.");

          bc[badgeId] = cards - cost;
          bl[badgeId] = lvl + 1;

          tx.update(ref, { badgeCards: bc, badgeLevels: bl });
        });
      } catch (e) {
        showError(e?.message || "Upgrade failed.");
      }
    }

    function renderBadges() {
      badgesGrid.innerHTML = "";

      for (const { id, rarity } of allBadgeIdsInOrder()) {
        const lvl = getLevelForBadge(id);
        const cards = getCardsForBadge(id);
        const cost = nextCardCost(rarity, lvl);
        const maxed = (cost === null);
        const canUpgrade = !maxed && cards >= cost;

        const card = document.createElement("div");
        card.className = "badge-card";

        const top = document.createElement("div");
        top.className = "badge-top";

        const left = document.createElement("div");
        const name = document.createElement("div");
        name.className = "badge-name";
        name.textContent = `Badge ${id}`;

        const meta = document.createElement("div");
        meta.className = "badge-meta";
        meta.textContent = maxed
          ? `Level ${lvl} • ${rarity} • max upgrades reached`
          : `Level ${lvl} • ${rarity} • ${cards}/${cost}`;

        left.appendChild(name);
        left.appendChild(meta);

        const right = document.createElement("div");
        right.className = "badge-count";
        right.textContent = `cards: ${cards}`;

        top.appendChild(left);
        top.appendChild(right);
        card.appendChild(top);

        const btn = document.createElement("button");
        btn.className = "upgrade-btn";
        btn.textContent = `Upgrade to Level ${lvl + 1}`;
        btn.style.display = (currentUser && canUpgrade) ? "block" : "none";
        btn.onclick = () => upgradeBadge(id, rarity);
        card.appendChild(btn);

        badgesGrid.appendChild(card);
      }
    }

    // ====== Chest logic ======
    function weightedPickFinalLevel() {
      const r = Math.random();
      let acc = 0;
      for (const w of FINAL_LEVEL_WEIGHTS) {
        acc += w.p;
        if (r <= acc) return w.level;
      }
      return 6;
    }
    function shuffleInPlace(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }
    function buildOutcomesForFinalLevel(level) {
      const upsNeeded = level - 1;
      const staysNeeded = 5 - upsNeeded;
      const arr = [];
      for (let i = 0; i < upsNeeded; i++) arr.push("UP");
      for (let i = 0; i < staysNeeded; i++) arr.push("STAY");
      return shuffleInPlace(arr);
    }
    function pickUniform(arr) { return arr[Math.floor(Math.random() * arr.length)]; }
    function decideDropForLevel(level) {
      const options = CARD_REWARD_TABLE[level];
      const allowedRarities = Object.keys(options);
      const rarity = pickUniform(allowedRarities);
      const amount = options[rarity];
      const badgeId = pickUniform(BADGES[rarity]);
      return { rarity, badgeId, amount };
    }

    function setThemeForLevel(level) {
      overlay.classList.remove("t1","t2","t3","t4","t5","t6");
      overlay.classList.add("t" + level);
      chestEl.classList.remove("skin1","skin2","skin3","skin4","skin5","skin6");
      chestEl.classList.add("skin" + level);
    }

    function renderLadder(level) {
      ladder.innerHTML = "";
      for (let i = 1; i <= 6; i++) {
        const r = document.createElement("div");
        r.className = "rung" + (i <= level ? " on" : "");
        ladder.appendChild(r);
      }
    }

    function renderDots(doneCount) {
      dots.innerHTML = "";
      for (let i = 0; i < 5; i++) {
        const d = document.createElement("div");
        d.className = "dot" + (i < doneCount ? " done" : "");
        dots.appendChild(d);
      }
    }

    function updateSpinLabels() {
      const spinNumber = Math.min(5, spinIndex + 1);
      const left = 5 - spinIndex;
      spinLabel.textContent = `Spin ${spinNumber} of 5 • Spins left: ${left}`;
    }

    function showToast(text) {
      toast.textContent = text;
      toast.classList.remove("show");
      void toast.offsetWidth;
      toast.classList.add("show");
    }

    function chestSpinAnim() {
      chestEl.classList.remove("shake");
      void chestEl.offsetWidth;
      chestEl.classList.add("shake");
    }

    function setOverlayVisible(v) {
      overlay.classList.toggle("show", v);
      document.body.style.overflow = v ? "hidden" : "";
    }

    function wait(ms) { return new Promise(res => setTimeout(res, ms)); }

    function resetChestSession() {
      opening = false;
      spinIndex = 0;
      currentLevel = 1;
      outcomes = [];
      finalLevel = 1;
      decidedDrop = null;

      result.classList.remove("show");
      levelSub.textContent = "Tap anywhere to spin";
      setThemeForLevel(1);
      renderLadder(1);
      renderDots(0);
      updateSpinLabels();
      levelText.textContent = "LEVEL 1";
    }

    // Consume 1 chest BEFORE opening (so reloads don’t keep the same chest)
    openChestBtn.addEventListener("click", async () => {
      if (!currentUser) {
        showError("Please sign in using the Login button.");
        return;
      }
      if (opening) return;
      if (luckyChests < 1) {
        showError("No Lucky Chests available.");
        return;
      }

      try {
        openChestBtn.disabled = true;

        await runTransaction(db, async (tx) => {
          const ref = userDocRef(currentUser.uid);
          const snap = await tx.get(ref);
          const data = snap.data() || {};

          const ch = (typeof data.chests === "object" && data.chests) ? { ...data.chests } : {};
          const lucky = (typeof ch.lucky === "number") ? ch.lucky : 0;
          if (lucky < 1) throw new Error("No Lucky Chests available.");
          ch.lucky = lucky - 1;

          tx.update(ref, { chests: ch });
        });

        startChestOpen();
      } catch (e) {
        showError(e?.message || "Could not open chest.");
        openChestBtn.disabled = false;
      }
    });

    function startChestOpen() {
      resetChestSession();
      opening = true;

      finalLevel = weightedPickFinalLevel();
      outcomes = buildOutcomesForFinalLevel(finalLevel);
      decidedDrop = decideDropForLevel(finalLevel);

      setOverlayVisible(true);
    }

    overlay.addEventListener("click", async () => {
      if (!opening) return;
      if (result.classList.contains("show")) return;
      if (spinIndex >= 5) return;

      chestSpinAnim();
      levelSub.textContent = "Spinning...";
      updateSpinLabels();

      await wait(650);

      const outcome = outcomes[spinIndex];
      if (outcome === "STAY") {
        showToast("STAY");
      } else {
        showToast("UP!");
        currentLevel = Math.min(6, currentLevel + 1);
        setThemeForLevel(currentLevel);
      }

      spinIndex++;
      renderDots(spinIndex);
      renderLadder(currentLevel);
      levelText.textContent = `LEVEL ${currentLevel}`;

      if (spinIndex < 5) {
        levelSub.textContent = "Tap anywhere to spin";
      } else {
        levelSub.textContent = "Complete";
        await finishChest();
      }

      updateSpinLabels();
    });

    resultOk.addEventListener("click", () => {
      setOverlayVisible(false);
      opening = false;
      openChestBtn.disabled = !currentUser || luckyChests < 1;
    });

    async function finishChest() {
      if (!decidedDrop) decidedDrop = decideDropForLevel(finalLevel);
      const { rarity, badgeId, amount } = decidedDrop;

      try {
        await runTransaction(db, async (tx) => {
          const ref = userDocRef(currentUser.uid);
          const snap = await tx.get(ref);
          const data = snap.data() || {};

          const bc = (typeof data.badgeCards === "object" && data.badgeCards) ? { ...data.badgeCards } : {};
          const prev = (typeof bc[badgeId] === "number") ? bc[badgeId] : 0;
          bc[badgeId] = prev + amount;

          tx.update(ref, { badgeCards: bc });
        });
      } catch (e) {
        showError(e?.message || "Failed to award badge cards.");
      }

      resultTitle.textContent = `Final Level: ${currentLevel}`;
      resultBody.textContent = `Drop: ${amount} cards → ${rarity} badge "${badgeId.toUpperCase()}"`;
      result.classList.add("show");
    }

    // init
    resetChestSession();
    renderBadges();
  </script>
</body>
</html>
